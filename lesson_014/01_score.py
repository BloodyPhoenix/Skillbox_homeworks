# -*- coding: utf-8 -*-

# Вас взяли на работу в молодой стартап. Идея стартапа - предоставлять сервис расчета результатов игр.
# Начать решили с боулинга, упрощенной версии.
#
# Правила такие.
#
# Всего 10 кеглей. Игра состоит из 10 фреймов. В одном фрейме до 2х бросков, цель - сбить все кегли.
# Результаты фрейма записываются символами:
#   «Х» – «strike», все 10 кеглей сбиты первым броском
#   «<число>/», например «4/» - «spare», в первый бросок сбиты 4 кегли, во второй – остальные
#   «<число><число>», например, «34» – в первый бросок сбито 3, во второй – 4 кегли.
#   вместо <число> может стоять прочерк «-», например «-4» - ни одной кегли не было сбито за первый бросок
# Результат игры – строка с записью результатов фреймов. Символов-разделителей между фреймами нет.
# Например, для игры из 4 фреймов запись результатов может выглядеть так:
#   «Х4/34-4»
# Предлагается упрощенный способ подсчета количества очков:
#   «Х» – strike всегда 20 очков
#   «4/» - spare всегда 15 очков
#   «34» – сумма 3+4=7
#   «-4» - сумма 0+4=4
# То есть для игры «Х4/34-4» сумма очков равна 20+15+7+4=46
#
# Надо написать python-модуль (назвать bowling), предоставляющий API расчета количества очков:
# функцию get_score, принимающую параметр game_result. Функция должна выбрасывать исключения,
# когда game_result содержит некорректные данные. Использовать стандартные исключения по максимуму,
# если не хватает - создать свои.
#
# Обязательно написать тесты на этот модуль. Расположить в папке tests.

# Из текущего файла сделать консольную утилиту для определения количества очков, с помощью пакета argparse
# Скрипт должен принимать параметр --result и печатать на консоль:
#   Количество очков для результатов ХХХ - УУУ.

import bowling
import argparse


def main():
    parser = argparse.ArgumentParser(description="A score counter")
    parser.add_argument("--result", default=None, type=str, help="Game result")
    args = parser.parse_args()
    result = args.result
    try:
        score = bowling.get_score(result)
        print(f"Количество очков для результатов {result} - {score}")
    except ValueError as error:
        print(f"Ошибка входных данных: {error}, {error.args}")


if __name__ == "__main__":
    main()


# При написании кода помнить, что заказчик может захотеть доработок и новых возможностей...
# И, возможно, вам пригодится паттерн проектирования "Состояние",
#   см https://clck.ru/Fudd8 и https://refactoring.guru/ru/design-patterns/state


# TODO предлагаю вам полностью применить структуру из
# TODO https://refactoring.guru/ru/design-patterns/state
# TODO полностью описать интерфейсы и механизм смены состояния

# TODO также описываем класс контекст как в примере
# TODO в ините будем хранить результат игры который будем потом обрабатывать
# TODO общий результат, можно еше хранить результат первого и второго броска чтобы их потом складывать
# TODO метод который реализует переключения состояния
# TODO и два метода которые будет каждый вызывать состояние первого и второго броска.

# TODO далее реализуем абстрактный класс состояния
# TODO будет состоять из свойства, сеттера, и двух абстрактных методов

# TODO далее реализуем классы состояний, в которых переопредляем абстрактные методы которые определили в состоянии


# TODO попробуйте переписать задачу на паттерн состояния
# TODO https://refactoring.guru/ru/design-patterns/state используя вот этот пример.

# TODO у вас будет два состояния первый брос, и второй бросок.
# TODO там мы переопределите по функции их разно поведение при смене состояния

# TODO первый бросок будет знать как обработать только те данные и результат который ему заложен,
# TODO и второй бросок нечего не будет знать как обрабатывать первый.

# TODO у вас фрейм из 54
# TODO первый бросок(состояние_1) обрабатывает 5, второй бросок(состояние_2) - 4.
