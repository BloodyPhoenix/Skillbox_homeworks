# -*- coding: utf-8 -*-

import os.path
import zipfile

# Подсчитать статистику по буквам в романе Война и Мир.
# Входные параметры: файл для сканирования
# Статистику считать только для букв алфавита (см функцию .isalpha() для строк)
#
# Вывести на консоль упорядоченную статистику в виде
# +---------+----------+
# |  буква  | частота  |
# +---------+----------+
# |    А    |   77777  |
# |    Б    |   55555  |
# |   ...   |   .....  |
# |    a    |   33333  |
# |    б    |   11111  |
# |   ...   |   .....  |
# +---------+----------+
# |  итого  | 9999999  |
# +---------+----------+
#
# Упорядочивание по частоте - по убыванию. Ширину таблицы подберите по своему вкусу
#
# Требования к коду: он должен быть готовым к расширению функциональности - делать сразу на классах.
# Для этого пригодится шаблон проектирование "Шаблонный метод"
#   см https://refactoring.guru/ru/design-patterns/template-method
#   и https://gitlab.skillbox.ru/vadim_shandrinov/python_base_snippets/snippets/4


class InOutBlock:

    def __init__(self, file_name):
        self.file_name = file_name
        self.statistics = {}
        self.letters_total = 0

    # А потом нам понадобится применить этот скрипт к файлу, который лежит в другой папке
    # и совершенно ВНЕЗАПНО ничего не сработает.
    # Сейчас скрипт хотя бы обрабатывает хотя бы все вложенные папки от директории запуска
    # А если мы привязываемся к "безусловной" папке python_snippets, то можно сделать проще.
    # os.chdir("python_snippets")
    # Нам же не нужно даже подобие универсальности скрипта...

    # TODO универсальность подразумевает поиск файла по всем папка вложеным и делать перебор
    #  файлов на соответствие имени ?

    # Что-то у меня опять сомнения, что это повысит способность скрипта обрабатывать файлы помимо заданных условием
    # Наверное, потому, что оно отработает только с конкретным архивом с конкретным содержимым.

    # TODO допустим у нас есть место где хранятся данный как правило это не рендомная пака а вполне конкретная
    # TODO также имя папки где искать тоже можно задать в скрипте.


    def find_file_directory(self):
        # получаем текущую рабочую директорию
        path = os.getcwd()
        # получаем список директорий и поддиректорий в ней
        # TODO тут мы получаем не dirs а dirpath, dirnames, filenames сразу три параметра
        # TODO незабываем что переменные пишутся в стиле snake_case
        dirs = os.walk(path)
        # заводим цикл для проверки всех путей в исходной папке
        for directory in dirs:
            # первый элемент в списке-элементе, возвращённом os.path - это путь до папки
            normpath = os.path.normpath(directory[0])
            # переключаемся на директорию из списка. Без явого перключения Ubuntu ичего не делает.
            # TODO предлагаю вам без этих переключений формировать путь до файла, потому что возможно в ходе доработки
            # TODO скрипта нужно буть брать ресурсы из других директорий или из корня с проектом
            os.chdir(normpath)
            # если среди файлов в директории есть запрошенный нами файл - прерываем цикл, так как мы уже в нужной
            # директории

            if self.file_name in directory[2]:
                break
            else:
                # TODO большая вложенность получается, выносим в отдельный метод
                #  если сейчас на код посмотреть то сюда
                #  мы еще раз зайдем и переберем все файлы но безрезультатно потому что у нас файл не zip
                # если нет, проверяем, нет ли в папке архивов
                # TODO очень медленная и ресурсоемкая конструкция перебирать файлы таким образом.
                # TODO гораздо проще в самом начале сделать проверку на окончание и если зип то только тогда запускать
                # TODO такой перебор
                for file in directory[2]:
                    # если архив есть, открываем его на чтение и проверяем содержимое
                    if zipfile.is_zipfile(file):
                        archive = zipfile.ZipFile(file, "r")
                        content = archive.namelist()
                        # если файл есть в архиве, то раззиповываем его и прерываем цикл обхода папок
                        if self.file_name in content:
                            archive.extract(self.file_name)
                            break
        # TODO в любом случае принт сработает
        print("Запрашиваемый файл не найден в данной директории или вложенных.")

    def count_letters(self):
        # TODO тут пишем условие если self.file_name имеет окончание .zip

        # А если мы его уже после предыдущего теста раззиповали?..
        # Почему не работать сразу с именем конечного файла, который нам нужен?

        # TODO верхняя проверка имелась для того что если вы дали зип файл на вход программа его сама раззипует
        # TODO если у вас как сейчас текстовый файл то она будет работать только с именем

        # TODO self.file_name и так строка зачем ее еще раз преобразовывать
        if str(self.file_name).endswith(".txt"):
            # TODO зачем запускать файл если он может лежать в корне! Нужно делать проверку
            self.find_file_directory()
            with open(self.file_name, "r", encoding="cp1251") as file:
                for line in file:
                    self.check_symbols(line)
            self.sort_statistics()
            self.print_result()

    def sort_statistics(self):
        sorted(self.statistics)

    def check_symbols(self, line):
        for char in line:
            if char.isalpha():
                if char in self.statistics:
                    self.statistics[char] = self.statistics[char] + 1
                else:
                    self.statistics[char] = 1
                self.letters_total += 1

    def print_result(self):
        print("""+---------+----------+
|  буква  | частота  |
+---------+----------+""")
        for key in self.statistics:
            value = self.statistics[key]
            print("|{:^9}|{:^10}|".format(key, value))
        print("+---------+----------+")
        print("|{:^9}|{:^10}|".format("Итого", self.letters_total))
        print("+---------+----------+")


# TODO если файл изменить то код падает, как бы логически не завершается программа
test = InOutBlock(file_name="voyna-i-mir.txt")
test.count_letters()


# После зачета первого этапа нужно сделать упорядочивание статистики
#  - по частоте по возрастанию
#  - по алфавиту по возрастанию
#  - по алфавиту по убыванию
